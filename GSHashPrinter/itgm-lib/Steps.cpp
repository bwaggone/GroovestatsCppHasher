#include <algorithm>
#include <regex>

#include "Steps.h"
#include "RageUtil.h"

Steps::Steps(Song* song) : song_(song) {}


std::string Steps::MinimizeChartString() {

	// We can potentially minimize the chart to get the most compressed
	// form of the actual chart data.
	// NOTE(teejusb): This can be more compressed than the data actually
	// generated by StepMania. This is okay because the charts would still
	// be considered equivalent.
	// E.g. 0000                      0000
	// 		0000  -- minimized to -->
	// 		0000
	// 		0000
	// 		StepMania will always generate the former since quarter notes are
	// 		the smallest quantization.

	std::regex anyNote("[^0]");

	std::vector<std::string> measures;
	std::string minimizedNoteData = "";
	util::split(raw_chart_, ",", measures, true);
	for (unsigned m = 0; m < measures.size(); m++)
	{

		util::Trim(measures[m]);
		bool isEmpty = true;
		bool allZeroes = true;
		bool minimal = false;
		std::vector<std::string> lines;
		util::split(measures[m], "\n", lines, true);
		while (!minimal && lines.size() % 2 == 0)
		{
			// If every other line is all 0s, we can minimize the measure
			for (unsigned i = 1; i < lines.size(); i += 2)
			{
				util::Trim(lines[i]);
				std::cmatch m;
				if (std::regex_search(lines[i].c_str(), m, anyNote))
				{
					allZeroes = false;
					break;
				}
			}

			if (allZeroes)
			{
				// Iterate through lines, removing every other item.
				// Note that we're removing the odd indices, so we
				// call `++it;` and then erase the following line
				auto it = lines.begin();
				while (it != lines.end())
				{
					++it;
					if (it != lines.end())
					{
						it = lines.erase(it);
					}
				}
			}
			else
			{
				minimal = true;
			}
		}

		// Once the measure has been minimized, make sure all of the lines are
		// actually trimmed.
		// (for some reason, the chart returned by GetSMNoteData() have a lot
		//  of extra newlines)
		for (unsigned l = 0; l < lines.size(); l++)
		{
			util::Trim(lines[l]);
		}

		// Then, rejoin the lines together to make a measure,
		// and add it to minimizedNoteData.
		minimizedNoteData += util::join("\n", lines);
		if (m < measures.size() - 1)
		{
			minimizedNoteData += "\n,\n";
		}
	}
	return minimizedNoteData;
}


void Steps::CalculateAndSetGSHash(std::string bpm_string) {
	std::string chart_and_bpms = MinimizeChartString() + bpm_string;
	SetGSHash(util::BinaryToHex(util::GetSHA1ForString(chart_and_bpms)).substr(0, 16));
}

void Steps::SetSMNoteData(const std::string& notes_comp_)
{
	note_data_.Init();
	m_bNoteDataIsFilled = false;
	m_sNoteDataCompressed = notes_comp_;
}

void Steps::SetStepsType(std::string steps_type) {
	for (char& c : steps_type) {
		c = std::tolower(c);
	}
	if (enums::kStringToStepsType.find(steps_type) == enums::kStringToStepsType.end()) {
		steps_type_ = enums::StepsType_Invalid;
		return;
	}
	steps_type_ = enums::kStringToStepsType[steps_type];
}

void Steps::DeAutogen(bool copy_note_data) {
	// TODO (bwaggone): This.
	/*if (!parent)
		return; // OK

	if (bCopyNoteData)
		Decompress();	// fills in m_pNoteData with sliding window transform

	m_sDescription = Real()->m_sDescription;
	m_sChartStyle = Real()->m_sChartStyle;
	m_Difficulty = Real()->m_Difficulty;
	m_iMeter = Real()->m_iMeter;
	std::copy(Real()->m_CachedRadarValues, Real()->m_CachedRadarValues + NUM_PLAYERS, m_CachedRadarValues);
	std::copy(Real()->m_CachedTechCounts, Real()->m_CachedTechCounts + NUM_PLAYERS, m_CachedTechCounts);

	m_CachedNpsPerMeasure.assign(Real()->m_CachedNpsPerMeasure.begin(), Real()->m_CachedNpsPerMeasure.end());
	m_CachedNotesPerMeasure.assign(Real()->m_CachedNotesPerMeasure.begin(), Real()->m_CachedNotesPerMeasure.end());


	m_sCredit = Real()->m_sCredit;
	parent = nullptr;

	if (bCopyNoteData)
		Compress();*/
}

void Steps::SetChartStyle(std::string chart_style) {
	DeAutogen();
	chart_style_ = chart_style;
}

bool Steps::MakeValidEditDescription(std::string& preferred_description)
{
	if (int(preferred_description.size()) > kMaxStepsDescriptionLength)
	{
		preferred_description = preferred_description.substr(0, std::min(static_cast<int>(preferred_description.size()), kMaxStepsDescriptionLength));
		return true;
	}
	return false;
}

void Steps::SetDifficultyAndDescription(enums::Difficulty difficulty, std::string desc)
{
	DeAutogen();
	difficulty_ = difficulty;
	description_ = desc;
	if (GetDifficulty() == enums::Difficulty_Edit)
		MakeValidEditDescription(description_);
}


void Steps::SetMeter(int meter) {
	DeAutogen();
	meter_ = meter;
}

// bwaggone TODO: this
void Steps::TidyUpData()
{
	// Don't set the StepsType to dance single if it's invalid.  That just
	// causes unrecognized charts to end up where they don't belong.
	// Leave it as StepsType_Invalid so the Song can handle it specially.  This
	// is a forwards compatibility feature, so that if a future version adds a
	// new style, editing a simfile with unrecognized Steps won't silently
	// delete them. -Kyz
	/*if (steps_type_enum_ == StepsType_Invalid)
	{
		//LOG->Warn("Detected steps with unknown style '%s' in '%s'", m_StepsTypeStr.c_str(), m_pSong->m_sSongFileName.c_str());
	}
	else if (steps_type_ == "")
	{
		//steps_type_ = GAMEMAN->GetStepsTypeInfo(m_StepsType).szName;
	}

	if (GetDifficulty() == Difficulty_Invalid)
		SetDifficulty(StringToDifficulty(GetDescription()));

	if (GetDifficulty() == Difficulty_Invalid)
	{
		if (GetMeter() == 1)	SetDifficulty(Difficulty_Beginner);
		else if (GetMeter() <= 3)	SetDifficulty(Difficulty_Easy);
		else if (GetMeter() <= 6)	SetDifficulty(Difficulty_Medium);
		else				SetDifficulty(Difficulty_Hard);
	}

	if (GetMeter() < 1) // meter is invalid
		SetMeter(int(PredictMeter()));*/
}