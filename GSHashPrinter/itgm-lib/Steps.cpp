#include <algorithm>
#include <regex>

#include "NoteDataUtil.h"
#include "Song.h"
#include "Steps.h"
#include "RageUtil.h"
#include "TimingData.h"

Steps::Steps(Song* song) : song_(song) {}

void Steps::GetNoteData(NoteData& noteDataOut) const
{
	Decompress();

	if (m_bNoteDataIsFilled)
	{
		noteDataOut = note_data_;
	}
	else
	{
		noteDataOut.ClearAll();
		noteDataOut.SetNumTracks(kStepTypeInfos[steps_type_].iNumTracks);
	}
}


std::string Steps::MinimizedChartString() {

	// We can potentially minimize the chart to get the most compressed
	// form of the actual chart data.
	// NOTE(teejusb): This can be more compressed than the data actually
	// generated by StepMania. This is okay because the charts would still
	// be considered equivalent.
	// E.g. 0000                      0000
	// 		0000  -- minimized to -->
	// 		0000
	// 		0000
	// 		StepMania will always generate the former since quarter notes are
	// 		the smallest quantization.

	std::regex anyNote("[^0]");

	std::string smNoteData = "";
	NoteData noteData;
	GetNoteData(noteData);
	NoteDataUtil::GetSMNoteDataString(noteData, smNoteData);

	if (smNoteData == "")
	{
		return "";
	}

	// Strip any comments from smNoteData
	std::regex commentRegex("//[^\n]*");
	std::string deCommentedNoteData = std::regex_replace(smNoteData, commentRegex, "");

	std::string minimizedNoteData = "";

	std::vector<std::string> measures;
	
	util::split(deCommentedNoteData, ",", measures, true);
	for (unsigned m = 0; m < measures.size(); m++)
	{

		util::Trim(measures[m]);
		bool isEmpty = true;
		bool allZeroes = true;
		bool minimal = false;
		std::vector<std::string> lines;
		util::split(measures[m], "\n", lines, true);
		while (lines.size() > 0 && !minimal && lines.size() % 2 == 0)
		{
			// If every other line is all 0s, we can minimize the measure
			for (unsigned i = 1; i < lines.size(); i += 2)
			{
				util::Trim(lines[i]);
				std::cmatch m;
				if (std::regex_search(lines[i].c_str(), m, anyNote))
				{
					allZeroes = false;
					break;
				}
			}

			if (allZeroes)
			{
				// Iterate through lines, removing every other item.
				// Note that we're removing the odd indices, so we
				// call `++it;` and then erase the following line
				auto it = lines.begin();
				while (it != lines.end())
				{
					++it;
					if (it != lines.end())
					{
						it = lines.erase(it);
					}
				}
			}
			else
			{
				minimal = true;
			}
		}

		// Once the measure has been minimized, make sure all of the lines are
		// actually trimmed.
		// (for some reason, the chart returned by GetSMNoteData() have a lot
		//  of extra newlines)
		for (unsigned l = 0; l < lines.size(); l++)
		{
			util::Trim(lines[l]);
		}

		// Then, rejoin the lines together to make a measure,
		// and add it to minimizedNoteData.
		minimizedNoteData += util::join("\n", lines);
		if (m < measures.size() - 1)
		{
			minimizedNoteData += "\n,\n";
		}
	}
	return minimizedNoteData;
}

const TimingData* Steps::GetTimingData() const
{
	return timing_data_.empty() ? &song_->timing_data_ : &timing_data_;
}

void Steps::Decompress() const
{
	const_cast<Steps*>(this)->Decompress();
}

void Steps::GetSMNoteData(std::string& notes_comp_out) const
{
	if (m_sNoteDataCompressed.empty())
	{
		if (!m_bNoteDataIsFilled)
		{
			/* no data is no data */
			notes_comp_out = "";
			return;
		}

		NoteDataUtil::GetSMNoteDataString(note_data_, m_sNoteDataCompressed);
	}

	notes_comp_out = m_sNoteDataCompressed;
}

void Steps::Decompress()
{
	if (m_bNoteDataIsFilled)
		return;	// already decompressed

	if (!filename_.empty() && m_sNoteDataCompressed.empty())
	{
		// TODO(bwaggone): This, even though it seems to be useless? Double check when notedata compressed is actually written to be sure.
		//
		// We have NoteData on disk and not in memory. Load it.
		/*if (!this->GetNoteDataFromSimfile())
		{
			std::cout << "Couldn't load the " << kDifficultyToString[difficulty_] << "chart's NoteData from " << filename_;
			return;
		}*/

		GetSMNoteData(m_sNoteDataCompressed);
	}

	if (m_sNoteDataCompressed.empty())
	{
		/* there is no data, do nothing */
	}
	else
	{
		// load from compressed
		bool bComposite = kStepTypeInfos[steps_type_].m_StepsTypeCategory == StepsTypeCategory_Routine;
		m_bNoteDataIsFilled = true;
		note_data_.SetNumTracks(kStepTypeInfos[steps_type_].iNumTracks);

		// TODO(bwaggone): This
		NoteDataUtil::LoadFromSMNoteDataString(note_data_, m_sNoteDataCompressed, bComposite);
	}
}

// ACTUAL ITGM VERSION:
void Steps::CalculateGrooveStatsHash()
{
	// When the game first boots up, it will load the GrooveStatsHash from the
	// cache.
	// This should keep the initial boot snappy, especially since hashes should
	// almost never change.
	// If this function is then called again (say in ScreenEval), we can
	// recalculate the hash and use that for submission.

	// No caching in this script.
	/*if (m_iGrooveStatsHashVersion == CURRENT_GROOVE_STATS_HASH_VERSION &&
		m_bIsCachedGrooveStatsHashJustLoaded == true)
	{
		m_bIsCachedGrooveStatsHashJustLoaded = false;
		return;
	}*/
	this->Decompress();

	std::string smNoteData = this->MinimizedChartString();

	TimingData* timingData = this->GetTimingData();
	std::vector<TimingSegment*> segments = timingData->GetTimingSegments(SEGMENT_BPM);
	std::vector<std::string> bpmStrings;
	bpmStrings.reserve(segments.size());
	for (TimingSegment* segment : segments)
	{
		BPMSegment* bpmSegment = ToBPM(segment);
		float beat = bpmSegment->GetBeat();
		float bpm = bpmSegment->GetBPM();
		std::string segmentStr = util::NormalizeDecimal(beat) + "=" + util::NormalizeDecimal(bpm);
		bpmStrings.push_back(segmentStr);
	}
	std::string bpmString = util::join(",", bpmStrings);

	smNoteData.append(bpmString);
	std::string gsKey = util::BinaryToHex(util::GetSHA1ForString(smNoteData));
	gsKey = gsKey.substr(0, 16);
	groovestats_hash_ = gsKey;
	groovestats_version_ = 3;
}

void Steps::SetSMNoteData(const std::string& notes_comp_)
{
	note_data_.Init();
	m_bNoteDataIsFilled = false;
	m_sNoteDataCompressed = notes_comp_;
}

void Steps::SetStepsType(std::string steps_type) {
	for (char& c : steps_type) {
		c = std::tolower(c);
	}
	if (kStringToStepsType.find(steps_type) == kStringToStepsType.end()) {
		steps_type_ = StepsType_Invalid;
		return;
	}
	steps_type_ = kStringToStepsType[steps_type];
}

void Steps::DeAutogen(bool copy_note_data) {
	// Autogenerated notes are used in engine for the HowToPlay screen.
	// Since this code isn't ever intended to auto generate anything, just treat
	// it as false and move on.
	return;
}

void Steps::SetChartStyle(std::string chart_style) {
	DeAutogen();
	chart_style_ = chart_style;
}

bool Steps::MakeValidEditDescription(std::string& preferred_description)
{
	if (int(preferred_description.size()) > kMaxStepsDescriptionLength)
	{
		preferred_description = preferred_description.substr(0, std::min(static_cast<int>(preferred_description.size()), kMaxStepsDescriptionLength));
		return true;
	}
	return false;
}

void Steps::SetDifficultyAndDescription(Difficulty difficulty, std::string desc)
{
	DeAutogen();
	difficulty_ = difficulty;
	description_ = desc;
	if (GetDifficulty() == Difficulty_Edit)
		MakeValidEditDescription(description_);
}


void Steps::SetMeter(int meter) {
	DeAutogen();
	meter_ = meter;
}

float Steps::PredictMeter() const
{
	// TODO(bwaggone): Maybe add Radar support.
	/*float pMeter = 0.775f;

	const float RadarCoeffs[NUM_RadarCategory] =
	{
		10.1f, 5.27f,-0.905f, -1.10f, 2.86f,
		0,0,0,0,0,0,0,0
	};
	const RadarValues& rv = GetRadarValues(PLAYER_1);
	for (int r = 0; r < NUM_RadarCategory; ++r)
		pMeter += rv[r] * RadarCoeffs[r];

	const float DifficultyCoeffs[NUM_Difficulty] =
	{
		-0.877f, -0.877f, 0, 0.722f, 0.722f, 0
	};
	pMeter += DifficultyCoeffs[GetDifficulty()];

	// Init non-radar values
	const float SV = rv[RadarCategory_Stream] * rv[RadarCategory_Voltage];
	const float ChaosSquare = rv[RadarCategory_Chaos] * rv[RadarCategory_Chaos];
	pMeter += -6.35f * SV;
	pMeter += -2.58f * ChaosSquare;
	if (pMeter < 1) pMeter = 1;
	return pMeter;*/
	return 0.00;
}

void Steps::TidyUpData()
{
	// Don't set the StepsType to dance single if it's invalid.  That just
	// causes unrecognized charts to end up where they don't belong.
	// Leave it as StepsType_Invalid so the Song can handle it specially.  This
	// is a forwards compatibility feature, so that if a future version adds a
	// new style, editing a simfile with unrecognized Steps won't silently
	// delete them. -Kyz
	if (steps_type_ == StepsType_Invalid)
	{
		std::cout << "Detected steps with unknown style " << steps_type_str_ << "in" << song_->filename;
	}
	else if (steps_type_str_ == "")
	{
		steps_type_str_ = kStepsTypeToString[steps_type_];
	}

	if (GetDifficulty() == Difficulty_Invalid) {
		SetDifficulty(kStringToDifficulty[GetDescription()]);
	}

	if (GetDifficulty() == Difficulty_Invalid)
	{
		if (GetMeter() == 1)	SetDifficulty(Difficulty_Beginner);
		else if (GetMeter() <= 3)	SetDifficulty(Difficulty_Easy);
		else if (GetMeter() <= 6)	SetDifficulty(Difficulty_Medium);
		else				SetDifficulty(Difficulty_Hard);
	}

	if (GetMeter() < 1) // meter is invalid
		SetMeter(int(PredictMeter()));
}